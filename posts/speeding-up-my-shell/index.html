<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>쉘 로딩 시간 개선하기 | Call Me Maru</title><meta name=keywords content="shell,oh-my-zsh,zsh"><meta name=description content="어느 순간부터 터미널의 시작 시간이 오래 걸리는 느낌이 들었다. 터미널을 자주 끄고 키고 하는 습관이 있어서, 시작할 때마다 3~4초동안 검은 화면에 비춰지는 내 얼굴을 봐야 했다. 1분 1초가 아까운데 3~4초의 시간을 내 얼굴을 보는데 사용하는 것은 너무 아깝다. 원인을 찾고 해결해서 속도를 개선하고 싶은 니즈로 구글링을 해봤다. 다행히, 나와 같은 니즈를 가지고 있는 사람의 잘 정리한 블로그 글을 발견했다. 방법만 알고 싶으면 해당 글을 봐도 좋지만, 나는 shell에 대한 지식이 하나도 없어서 글에 나오는 shell의 개념들을 이번 글에서 정리하며 노트북에서 3~4초 동안 검은 거울이 생기는 문제를 좀 더 짧게 나오도록 해보고자 한다."><meta name=author content="Maru"><link rel=canonical href=https://callmemaru.com/posts/speeding-up-my-shell/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c3c5a9254b830a86780948e6d12315ab2415589a7cc741b6a66fb30969bb38f5.css integrity="sha256-w8WpJUuDCoZ4CUjm0SMVqyQVWJp8x0G2pm+zCWm7OPU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://callmemaru.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://callmemaru.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://callmemaru.com/favicon-32x32.png><link rel=apple-touch-icon href=https://callmemaru.com/favicon-32x32.png><link rel=mask-icon href=https://callmemaru.com/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-113083768-3','auto');ga('send','pageview');}</script><meta property="og:title" content="쉘 로딩 시간 개선하기"><meta property="og:description" content="어느 순간부터 터미널의 시작 시간이 오래 걸리는 느낌이 들었다. 터미널을 자주 끄고 키고 하는 습관이 있어서, 시작할 때마다 3~4초동안 검은 화면에 비춰지는 내 얼굴을 봐야 했다. 1분 1초가 아까운데 3~4초의 시간을 내 얼굴을 보는데 사용하는 것은 너무 아깝다. 원인을 찾고 해결해서 속도를 개선하고 싶은 니즈로 구글링을 해봤다. 다행히, 나와 같은 니즈를 가지고 있는 사람의 잘 정리한 블로그 글을 발견했다. 방법만 알고 싶으면 해당 글을 봐도 좋지만, 나는 shell에 대한 지식이 하나도 없어서 글에 나오는 shell의 개념들을 이번 글에서 정리하며 노트북에서 3~4초 동안 검은 거울이 생기는 문제를 좀 더 짧게 나오도록 해보고자 한다."><meta property="og:type" content="article"><meta property="og:url" content="https://callmemaru.com/posts/speeding-up-my-shell/"><meta property="og:image" content="https://callmemaru.com/og_image.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-06T23:00:18+09:00"><meta property="article:modified_time" content="2021-03-06T23:00:18+09:00"><meta property="og:site_name" content="Call me maru"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://callmemaru.com/og_image.png"><meta name=twitter:title content="쉘 로딩 시간 개선하기"><meta name=twitter:description content="어느 순간부터 터미널의 시작 시간이 오래 걸리는 느낌이 들었다. 터미널을 자주 끄고 키고 하는 습관이 있어서, 시작할 때마다 3~4초동안 검은 화면에 비춰지는 내 얼굴을 봐야 했다. 1분 1초가 아까운데 3~4초의 시간을 내 얼굴을 보는데 사용하는 것은 너무 아깝다. 원인을 찾고 해결해서 속도를 개선하고 싶은 니즈로 구글링을 해봤다. 다행히, 나와 같은 니즈를 가지고 있는 사람의 잘 정리한 블로그 글을 발견했다. 방법만 알고 싶으면 해당 글을 봐도 좋지만, 나는 shell에 대한 지식이 하나도 없어서 글에 나오는 shell의 개념들을 이번 글에서 정리하며 노트북에서 3~4초 동안 검은 거울이 생기는 문제를 좀 더 짧게 나오도록 해보고자 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://callmemaru.com/posts/"},{"@type":"ListItem","position":2,"name":"쉘 로딩 시간 개선하기","item":"https://callmemaru.com/posts/speeding-up-my-shell/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"쉘 로딩 시간 개선하기","name":"쉘 로딩 시간 개선하기","description":"어느 순간부터 터미널의 시작 시간이 오래 걸리는 느낌이 들었다. 터미널을 자주 끄고 키고 하는 습관이 있어서, 시작할 때마다 3~4초동안 검은 화면에 비춰지는 내 얼굴을 봐야 했다. 1분 1초가 아까운데 3~4초의 시간을 내 얼굴을 보는데 사용하는 것은 너무 아깝다. 원인을 찾고 해결해서 속도를 개선하고 싶은 니즈로 구글링을 해봤다. 다행히, 나와 같은 니즈를 가지고 있는 사람의 잘 정리한 블로그 글을 발견했다. 방법만 알고 싶으면 해당 글을 봐도 좋지만, 나는 shell에 대한 지식이 하나도 없어서 글에 나오는 shell의 개념들을 이번 글에서 정리하며 노트북에서 3~4초 동안 검은 거울이 생기는 문제를 좀 더 짧게 나오도록 해보고자 한다.","keywords":["shell","oh-my-zsh","zsh"],"articleBody":"어느 순간부터 터미널의 시작 시간이 오래 걸리는 느낌이 들었다. 터미널을 자주 끄고 키고 하는 습관이 있어서, 시작할 때마다 3~4초동안 검은 화면에 비춰지는 내 얼굴을 봐야 했다. 1분 1초가 아까운데 3~4초의 시간을 내 얼굴을 보는데 사용하는 것은 너무 아깝다. 원인을 찾고 해결해서 속도를 개선하고 싶은 니즈로 구글링을 해봤다. 다행히, 나와 같은 니즈를 가지고 있는 사람의 잘 정리한 블로그 글을 발견했다. 방법만 알고 싶으면 해당 글을 봐도 좋지만, 나는 shell에 대한 지식이 하나도 없어서 글에 나오는 shell의 개념들을 이번 글에서 정리하며 노트북에서 3~4초 동안 검은 거울이 생기는 문제를 좀 더 짧게 나오도록 해보고자 한다.\n글을 시작하기 전에 나의 shell 시작 시간은 어떤지 알아보자.\n❯ for i in {1..5}; do /usr/bin/time $SHELL -i -c exit; done 나는 3.4초에서 3.6초가 나왔다. 느리다! 느리다!! 느리다!!!\n⚙️ 환경 내가 사용하고 있는 환경은 아래와 같다.\n 맥북 16인치 zsh \u0026 oh-my-zsh 기본 터미널 zsh plugin  git zsh-autosuggestions zsh-syntax-highlighting   virtual environments  pyenv    ⏱ 현재 shell 로딩 시간 측정 내가 지금 느린건 알겠는데, 얼마나 느린지 알아야지 개선 했을 때 빨라졌구나를 알 수 있지 않은가?\n측정하는 법은 꽤 간단하다.\n❯ for i in {1..5}; do /usr/bin/time $SHELL -i -c exit; done  for in / do / done: 꽤 직관적이다. 반복문인데 do 키워드로 해야할 일을 명시 해준다는게 인상적이다. ;: for 문을 한 줄로 작성 할 수 있게 해주는 구분자다. {1..5}: sequence를 만들어준다. 참조한 블로그에서는 $(seq 1 10)를 사용하는데, 구식 문법이라고 한다. 게다가 10번까지 체크할 필요도 없이 느려서 5회 측정하도록 변경하였다. /usr/bin/time: 뒤에 오는 명령어(예제에서는 $SHELL -i -c)가 실행되고 끝날 때까지의 시간을 측정해서 통계를 내주는 명령어다. $SHELL: 현재 실행되고 있는 shell을 실행시키는 명령어의 경로를 나타내는 환경 변수다. 내 shell은 zsh를 사용하고 있어서 echo $SHELL를 입력하면 /bin/zsh가 리턴 된다.  -i: shell을 강제로 interactive하게 만들어주는 인자다.(좀 더 알아보기) -c: 이 인자 뒤로 나오는 첫 번째 인자를 명령어로써 인식하고 실행시킨다.   exit: shell을 종료한다.   이 명령어를 실행하면 아래와 같이 출력 된다. 개인 터미널의 설정에 따라 추가적인 텍스트가 출력 될 수도 있다. 유심히 봐야 할 부분은 real, user, sys 키워드다.\n3.62 real 1.85 user 1.70 sys 3.52 real 1.88 user 1.65 sys 3.55 real 1.88 user 1.67 sys 3.57 real 1.88 user 1.70 sys 4.07 real 2.13 user 1.92 sys  real: 호출 후 시작부터 끝날 때까지 측정 된 시간이다. 이 글에서 우리가 개선하고자 하는 “shell이 시작하는 시간\"이라고 생각하시면 된다. user: 프로세스가 실행 될 때 kernel 외부에서 CPU가 소비한 시간이다. sys: 프로세스가 실행 될 때 kernel 내부에서 CPU가 소비한 시간이다. (real, user, sys 키워드에 대해 좀 더 자세히 알고 싶으면 필자가 참고한 글을 읽어보시는 것을 추천한다..)  시간이 너무 길다. 개선을 해보자.\n❗️ 개선을 시작하기 전에 이제 개선을 시작하게 되면 설정 파일들을 변경하고 반영 할 것이다. 아마도 제일 많이 ~/.zshrc 부분을 수정 할 것이다. 해당 파일의 변경 사항을 변하기 위해서 shell의 session을 다시 시작해야 하는데 exec zsh 명령어를 사용하면 된다.\n❯ exec zsh  이 부분에서 굉장히 놀랐는데, 평소에 ~/.zshrc 수정 사항을 반영하기 위해 source ~/.zshrc 명령어를 사용했기 때문이다. oh-my-zsh 공식 문서를 보면 source ~/.zshrc를 사용하는 것은 잘못된 방법이라고 말한다.  ⏱ Plugin 시간 측정 먼저 ~/.zshrc에 선언 된 플러그인이 걸리는 시간부터 측정해보자.\n~/.oh-my-zsh/oh-my-zsh.sh 파일을 열어보면 ~/.zshrc에 정의 된 플러그인을 로드하는 부분이 있다. 코드는 아래와 같다.\n# Load all of the plugins that were defined in ~/.zshrc for plugin ($plugins); do if [ -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh elif [ -f $ZSH/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH/plugins/$plugin/$plugin.plugin.zsh fi done 이제 이 코드에 시간을 측정하는 코드를 넣어보자.\n# Load all of the plugins that were defined in ~/.zshrc for plugin ($plugins); do timer=$(($(gdate +%s%N)/1000000)) if [ -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh elif [ -f $ZSH/plugins/$plugin/$plugin.plugin.zsh ]; then source $ZSH/plugins/$plugin/$plugin.plugin.zsh fi now=$(($(gdate +%s%N)/1000000)) elapsed=$(($now-$timer)) echo $elapsed\":\" $plugin done 추가 된 코드를 살펴 보면 timer라는 변수에 plugin 로드 시작 시간을 담아놓고, now라는 변수에 plugin 로드 끝 시간을 담아서 그 차이를 보고 걸리는 시간을 측정하는 것이다.\n측정하는 과정에 대해 자세히 알아보자\n $(()): 계산한 값을 변수에 넣을 때 사용하는 문법이다. gdate: GNU의 date 명령어이다.  +: %s, %N등 format을 사용하려면 접두로 붙혀야 한다. %s: 1970-01-01 00:00:00 UTC부터의 시간을 초(seconds)로 반환한다. %N: 시간을 나노초로 표현한다.    gdate 명령어는 Homebrew로 coreutils를 설치하면 사용 할 수 있는 명령어다.\n만약 설치하기 싫거나 Homebrew를 사용하지 않는다면 기본 내장 된 python을 사용하는 방법도 있다. (이때 python version에 따라 print 문법이 다르다는 것을 주의하자.)\ntimer=$(($(python -c 'from time import time; print(int(round(time() * 1000)))'))) now=$(($(python -c 'from time import time; print(int(round(time() * 1000)))')))  참고로 python으로 실행해보니 gdate보다 좀 더 로드 시간이 길었다. 아마 python 코드 실행 시간이 좀 더 걸린게 아닐까 추측해본다.   중요한 것은 둘 다 밀리 초로 환산해서 계산하고 있다.\n 내 맥북에서는 아래와 같이 나왔다\n❯ exec zsh 15: git 21: zsh-syntax-highlighting 7: zsh-autosuggestions 21 밀리초면 0.021초라는 말인데, 플러그인은 속도를 느리게 하는 범인이 아닌듯 하다..\n ❗️ 시간 측정이 끝나면 시간 측정 코드를 꼭 지우도록 하자!  🧭 더 확실한 원인을 찾아서 plugin이 치명적인 원인이 아니므로 zsh이 로드 될 때 일어나는 일들의 시간을 측정해야 한다.\nzsh은 기가막힌 프로파일링 모듈을 가지고 있는데, 이름하여 zsh/zprof다.\n굉장히 편리하게 사용 할 수 있다. 일단 ~/.zshrc 파일을 열어서 제일 첫 문장에 zmodload zsh/zprof를 추가 해준다.\nzmodload zsh/zprof # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # .... 잘 저장하고 exec zsh 명령어를 사용해서 shell을 다시 실행해준 후 아래와 같은 명령어를 실행하면 프로파일링한 결과를 얻을 수 있다.\n❯ zprof num calls time self name ----------------------------------------------------------------------------------- 1) 3 390.53 130.18 39.51% 390.53 130.18 39.51% _pyenv_virtualenv_hook 2) 1 159.78 159.78 16.17% 159.78 159.78 16.17% compdump 3) 1 350.09 350.09 35.42% 107.25 107.25 10.85% compinit 4) 781 83.97 0.11 8.50% 83.97 0.11 8.50% compdef ....  여기서 compdump, compinit, compdef도 꽤 많은 지분을 가지고 있는데, 잠깐 찾아보니 해당 함수들을 어떻게든 시간 최적화를 한다고 해도 부작용이 일어나지 않을거라는 보장이 없다고 한다. 분하지만 얘네들은 가만히 두자..  참고한 글의 저자는 프로파일링 정보 중 함수 이름 왼쪽에 있는 퍼센트(%) 값이 속도 개선을 하는데 도움이 된다고 한다. 저 퍼센트(%) 값은 쉘 로드 시간 중에 해당 함수가 로드 된 시간의 지분을 뜻한다. (일리 있는 말이다…!)\n범인을 찾았다! 파이썬 버전과 가상 환경 관리를 편하게 해주는 pyenv가 날 불편하게 만들고 있었다…🕵🏻‍♂️\n🔧 가상 환경 관리 툴과 속도 개선 두 마리 토끼 잡기! 제일 빠르고 편한 방법은 그냥 pyenv를 지우면 된다. 하지만 고작 1~2초의 이득을 보겠다고 세상 편리한 가상 환경 관리 툴을 지우는건 멍청한 짓이다.\n이제 참고한 글의 저자는 2가지 방법을 제시한다.\n Lazy Loading Caching Eval  개인적인 생각으로 2번째 방법은 caching으로 인해 리소스가 소모되고, 1번 방법보다 시간 최적화가 덜 되어 1번 방법을 선택하기로 했다.(사실 이건 실행하는 환경 관리 툴과 디바이스 별로 다를지도 모른다.) 2번 방법은 참고 글의 링크를 걸었으니, 참고하면 좋을듯 하다.\n💤 Lazy Loading 이 방법이 해결책이 되는 이유는 간단하다. 쉘이 실행 될 때마다 pyenv가 로드 될 필요가 없다는게 포인트다. 안 쓰는데 로드 할 필요가 없지 않은가? 그냥 내가 원할 때 로드해서 사용하면 된다.\n참고 글에서는 저자가 nvm을 사용하기 때문에, zsh-nvm 플러그인을 사용해서 해결하는 방법을 보여준다.\n슬프게도 pyenv에게는 zsh-nvm 같이 star가 많은 플러그인이 없다. 그래도 갓갓 개발자분들이 이미 만들어 놓았다. zsh-pyenv-lazy라는 플러그인인데 파일 설치도 간단하고 코드도 직관적이라 star와 last commit 날짜를 신경쓰지 않고 설치했다.\n 저자가 rbenv는 lazy load하는 편한 방법을 못 찾았다고 한다. 그래서 2번 방법을 사용하라고 하는데, zsh-pyenv-lazy처럼 구현 할 수 있지 않을까 하는 조심스러운 추측을 해본다.(내가 만들어볼까?)  플러그인 설치 후 기존에 입력 해놓은 pyenv 실행 코드를 ~/.zshrc에서 삭제했다.\n# 혹시 모르니 주석 처리~ # export PYENV_ROOT=\"$HOME/.pyenv\" # export PATH=\"$PYENV_ROOT/bin:$PATH\" # if command -v pyenv 1/dev/null 2\u00261; then # eval \"$(pyenv init -)\" # fi # eval \"$(pyenv virtualenv-init -)\" 그리고 다시 시간 측정을 하니..!\n❯ for i in {1..5}; do /usr/bin/time $SHELL -i -c exit; done 3.24 real 1.77 user 1.44 sys 2.87 real 1.52 user 1.34 sys 2.86 real 1.51 user 1.33 sys 2.87 real 1.51 user 1.34 sys 2.83 real 1.50 user 1.32 sys 대략 0.5~0.8초의 시간을 줄였다.(고작..? 현타가 좀 오는데..?)\n뭔가 아직 내가 발견하지 못한 원인들이 있을 것이다. 추후에 다시 한번 연구해봐야겠다.\n그래도 0.8초의 이득과 zsh, shell 문법에 대한 지식을 얻었기 때문에 나름 성공적이라고 생각하며 글을 마친다.\n Reference\n  https://blog.mattclemente.com/2020/06/26/oh-my-zsh-slow-to-load.html#handling-virtual-environments\n  https://man7.org/linux/man-pages/man1/time.1.html\n  https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1\n  https://linux.die.net/man/1/zsh\n  https://unix.stackexchange.com/questions/551654/what-does-zshs-i-option-actually-do\n  https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file\n  https://man7.org/linux/man-pages/man1/date.1.html\n  ","wordCount":"1263","inLanguage":"ko","datePublished":"2021-03-06T23:00:18+09:00","dateModified":"2021-03-06T23:00:18+09:00","author":[{"@type":"Person","name":"Maru"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://callmemaru.com/posts/speeding-up-my-shell/"},"publisher":{"@type":"Organization","name":"Call Me Maru","logo":{"@type":"ImageObject","url":"https://callmemaru.com/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://callmemaru.com/ accesskey=h title="Call Me Maru (Alt + H)">Call Me Maru</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://callmemaru.com/about/ title=About><span>About</span></a></li><li><a href=https://callmemaru.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>쉘 로딩 시간 개선하기</h1><div class=post-meta>March 6, 2021&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Maru</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#-%ed%99%98%ea%b2%bd aria-label="⚙️ 환경">⚙️ 환경</a></li><li><a href=#-%ed%98%84%ec%9e%ac-shell-%eb%a1%9c%eb%94%a9-%ec%8b%9c%ea%b0%84-%ec%b8%a1%ec%a0%95 aria-label="⏱ 현재 shell 로딩 시간 측정">⏱ 현재 shell 로딩 시간 측정</a></li><li><a href=#-%ea%b0%9c%ec%84%a0%ec%9d%84-%ec%8b%9c%ec%9e%91%ed%95%98%ea%b8%b0-%ec%a0%84%ec%97%90 aria-label="❗️ 개선을 시작하기 전에">❗️ 개선을 시작하기 전에</a></li><li><a href=#-plugin-%ec%8b%9c%ea%b0%84-%ec%b8%a1%ec%a0%95 aria-label="⏱ Plugin 시간 측정">⏱ Plugin 시간 측정</a></li><li><a href=#-%eb%8d%94-%ed%99%95%ec%8b%a4%ed%95%9c-%ec%9b%90%ec%9d%b8%ec%9d%84-%ec%b0%be%ec%95%84%ec%84%9c aria-label="🧭 더 확실한 원인을 찾아서">🧭 더 확실한 원인을 찾아서</a></li><li><a href=#-%ea%b0%80%ec%83%81-%ed%99%98%ea%b2%bd-%ea%b4%80%eb%a6%ac-%ed%88%b4%ea%b3%bc-%ec%86%8d%eb%8f%84-%ea%b0%9c%ec%84%a0-%eb%91%90-%eb%a7%88%eb%a6%ac-%ed%86%a0%eb%81%bc-%ec%9e%a1%ea%b8%b0 aria-label="🔧 가상 환경 관리 툴과 속도 개선 두 마리 토끼 잡기!">🔧 가상 환경 관리 툴과 속도 개선 두 마리 토끼 잡기!</a></li><li><a href=#-lazy-loading aria-label="💤 Lazy Loading">💤 Lazy Loading</a></li></ul></div></details></div><div class=post-content><p>어느 순간부터 터미널의 시작 시간이 오래 걸리는 느낌이 들었다. 터미널을 자주 끄고 키고 하는 습관이 있어서, 시작할 때마다 3~4초동안 검은 화면에 비춰지는 내 얼굴을 봐야 했다. 1분 1초가 아까운데 3~4초의 시간을 내 얼굴을 보는데 사용하는 것은 너무 아깝다. 원인을 찾고 해결해서 속도를 개선하고 싶은 니즈로 구글링을 해봤다. 다행히, 나와 같은 니즈를 가지고 있는 사람의 <a href=https://blog.mattclemente.com/2020/06/26/oh-my-zsh-slow-to-load.html target=_blank rel=noopener>잘 정리한 블로그 글</a>을 발견했다. 방법만 알고 싶으면 해당 글을 봐도 좋지만, 나는 shell에 대한 지식이 하나도 없어서 글에 나오는 shell의 개념들을 이번 글에서 정리하며 노트북에서 3~4초 동안 검은 거울이 생기는 문제를 좀 더 짧게 나오도록 해보고자 한다.</p><p>글을 시작하기 전에 나의 shell 시작 시간은 어떤지 알아보자.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>❯ <span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>1..5<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span> /usr/bin/time $SHELL -i -c exit; <span style=color:#66d9ef>done</span>
</code></pre></div><p>나는 3.4초에서 3.6초가 나왔다. 느리다! 느리다!! 느리다!!!</p><h2 id=-환경>⚙️ 환경<a hidden class=anchor aria-hidden=true href=#-환경>#</a></h2><p>내가 사용하고 있는 환경은 아래와 같다.</p><ul><li>맥북 16인치</li><li>zsh & oh-my-zsh</li><li>기본 터미널</li><li>zsh plugin<ul><li>git</li><li>zsh-autosuggestions</li><li>zsh-syntax-highlighting</li></ul></li><li>virtual environments<ul><li>pyenv</li></ul></li></ul><h2 id=-현재-shell-로딩-시간-측정>⏱ 현재 shell 로딩 시간 측정<a hidden class=anchor aria-hidden=true href=#-현재-shell-로딩-시간-측정>#</a></h2><p>내가 지금 느린건 알겠는데, 얼마나 느린지 알아야지 개선 했을 때 빨라졌구나를 알 수 있지 않은가?</p><p>측정하는 법은 꽤 간단하다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>❯ <span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>1..5<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span> /usr/bin/time $SHELL -i -c exit; <span style=color:#66d9ef>done</span>
</code></pre></div><ul><li><code>for in</code> / <code>do</code> / <code>done</code>: 꽤 직관적이다. 반복문인데 <code>do</code> 키워드로 해야할 일을 명시 해준다는게 인상적이다.</li><li><code>;</code>: for 문을 한 줄로 작성 할 수 있게 해주는 구분자다.</li><li><code>{1..5}</code>: sequence를 만들어준다. 참조한 블로그에서는 <code>$(seq 1 10)</code>를 사용하는데, 구식 문법이라고 한다. 게다가 10번까지 체크할 필요도 없이 느려서 5회 측정하도록 변경하였다.</li><li><code>/usr/bin/time</code>: 뒤에 오는 명령어(예제에서는 <code>$SHELL -i -c</code>)가 실행되고 끝날 때까지의 시간을 측정해서 통계를 내주는 <strong>명령어</strong>다.</li><li><code>$SHELL</code>: 현재 실행되고 있는 shell을 실행시키는 명령어의 경로를 나타내는 환경 변수다. 내 shell은 zsh를 사용하고 있어서 <code>echo $SHELL</code>를 입력하면 <code>/bin/zsh</code>가 리턴 된다.<ul><li><code>-i</code>: shell을 강제로 interactive하게 만들어주는 인자다.(<a href=https://unix.stackexchange.com/questions/551654/what-does-zshs-i-option-actually-do target=_blank rel=noopener>좀 더 알아보기</a>)</li><li><code>-c</code>: 이 인자 뒤로 나오는 첫 번째 인자를 명령어로써 인식하고 실행시킨다.</li></ul></li><li><code>exit</code>: shell을 종료한다.</li></ul><br><p>이 명령어를 실행하면 아래와 같이 출력 된다. 개인 터미널의 설정에 따라 추가적인 텍스트가 출력 될 수도 있다. 유심히 봐야 할 부분은 <code>real</code>, <code>user</code>, <code>sys</code> 키워드다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>  3.62 real         1.85 user         1.70 sys
  3.52 real         1.88 user         1.65 sys
  3.55 real         1.88 user         1.67 sys
  3.57 real         1.88 user         1.70 sys
  4.07 real         2.13 user         1.92 sys
</code></pre></div><ul><li><code>real</code>: 호출 후 시작부터 끝날 때까지 측정 된 시간이다. 이 글에서 우리가 개선하고자 하는 &ldquo;shell이 시작하는 시간"이라고 생각하시면 된다.</li><li><code>user</code>: 프로세스가 실행 될 때 kernel 외부에서 CPU가 소비한 시간이다.</li><li><code>sys</code>: 프로세스가 실행 될 때 kernel 내부에서 CPU가 소비한 시간이다.
(<code>real</code>, <code>user</code>, <code>sys</code> 키워드에 대해 좀 더 자세히 알고 싶으면 필자가 <a href=https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1 target=_blank rel=noopener>참고한 글</a>을 읽어보시는 것을 추천한다..)</li></ul><p>시간이 너무 길다. 개선을 해보자.</p><h2 id=-개선을-시작하기-전에>❗️ 개선을 시작하기 전에<a hidden class=anchor aria-hidden=true href=#-개선을-시작하기-전에>#</a></h2><p>이제 개선을 시작하게 되면 설정 파일들을 변경하고 반영 할 것이다. 아마도 제일 많이 <code>~/.zshrc</code> 부분을 수정 할 것이다. 해당 파일의 변경 사항을 변하기 위해서 shell의 session을 다시 시작해야 하는데 <code>exec zsh</code> 명령어를 사용하면 된다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>❯ exec zsh
</code></pre></div><ul><li>이 부분에서 굉장히 놀랐는데, 평소에 <code>~/.zshrc</code> 수정 사항을 반영하기 위해 <code>source ~/.zshrc</code> 명령어를 사용했기 때문이다. <a href=https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file target=_blank rel=noopener>oh-my-zsh 공식 문서</a>를 보면 <code>source ~/.zshrc</code>를 사용하는 것은 잘못된 방법이라고 말한다.</li></ul><h2 id=-plugin-시간-측정>⏱ Plugin 시간 측정<a hidden class=anchor aria-hidden=true href=#-plugin-시간-측정>#</a></h2><p>먼저 <code>~/.zshrc</code>에 선언 된 플러그인이 걸리는 시간부터 측정해보자.</p><p><code>~/.oh-my-zsh/oh-my-zsh.sh</code> 파일을 열어보면 <code>~/.zshrc</code>에 정의 된 플러그인을 로드하는 부분이 있다. 코드는 아래와 같다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#75715e># Load all of the plugins that were defined in ~/.zshrc</span>
<span style=color:#66d9ef>for</span> plugin <span style=color:#f92672>(</span>$plugins<span style=color:#f92672>)</span>; <span style=color:#66d9ef>do</span>
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh
  <span style=color:#66d9ef>elif</span> <span style=color:#f92672>[</span> -f $ZSH/plugins/$plugin/$plugin.plugin.zsh <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    source $ZSH/plugins/$plugin/$plugin.plugin.zsh
  <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>이제 이 코드에 시간을 측정하는 코드를 넣어보자.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#75715e># Load all of the plugins that were defined in ~/.zshrc</span>
<span style=color:#66d9ef>for</span> plugin <span style=color:#f92672>(</span>$plugins<span style=color:#f92672>)</span>; <span style=color:#66d9ef>do</span>
  timer<span style=color:#f92672>=</span><span style=color:#66d9ef>$(($(</span>gdate +%s%N<span style=color:#66d9ef>)</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1000000</span><span style=color:#66d9ef>))</span>
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh
  <span style=color:#66d9ef>elif</span> <span style=color:#f92672>[</span> -f $ZSH/plugins/$plugin/$plugin.plugin.zsh <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    source $ZSH/plugins/$plugin/$plugin.plugin.zsh
  <span style=color:#66d9ef>fi</span>
  now<span style=color:#f92672>=</span><span style=color:#66d9ef>$(($(</span>gdate +%s%N<span style=color:#66d9ef>)</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1000000</span><span style=color:#66d9ef>))</span>
  elapsed<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>$now<span style=color:#f92672>-</span>$timer<span style=color:#66d9ef>))</span>
  echo $elapsed<span style=color:#e6db74>&#34;:&#34;</span> $plugin
<span style=color:#66d9ef>done</span>
</code></pre></div><p>추가 된 코드를 살펴 보면 <code>timer</code>라는 변수에 plugin 로드 시작 시간을 담아놓고, <code>now</code>라는 변수에 plugin 로드 끝 시간을 담아서 그 차이를 보고 걸리는 시간을 측정하는 것이다.</p><p>측정하는 과정에 대해 자세히 알아보자</p><ul><li><code>$(())</code>: 계산한 값을 변수에 넣을 때 사용하는 문법이다.</li><li><code>gdate</code>: GNU의 <code>date</code> 명령어이다.<ul><li><code>+</code>: <code>%s</code>, <code>%N</code>등 format을 사용하려면 접두로 붙혀야 한다.</li><li><code>%s</code>: 1970-01-01 00:00:00 UTC부터의 시간을 초(seconds)로 반환한다.</li><li><code>%N</code>: 시간을 나노초로 표현한다.</li></ul></li></ul><p>gdate 명령어는 Homebrew로 <a href=https://formulae.brew.sh/formula/coreutils target=_blank rel=noopener>coreutils</a>를 설치하면 사용 할 수 있는 명령어다.</p><p>만약 설치하기 싫거나 Homebrew를 사용하지 않는다면 기본 내장 된 python을 사용하는 방법도 있다. (이때 python version에 따라 print 문법이 다르다는 것을 주의하자.)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>timer<span style=color:#f92672>=</span><span style=color:#66d9ef>$(($(</span>python -c <span style=color:#e6db74>&#39;from time import time; print(int(round(time() * 1000)))&#39;</span><span style=color:#66d9ef>)))</span>

now<span style=color:#f92672>=</span><span style=color:#66d9ef>$(($(</span>python -c <span style=color:#e6db74>&#39;from time import time; print(int(round(time() * 1000)))&#39;</span><span style=color:#66d9ef>)))</span>
</code></pre></div><ul><li>참고로 python으로 실행해보니 <code>gdate</code>보다 좀 더 로드 시간이 길었다. 아마 python 코드 실행 시간이 좀 더 걸린게 아닐까 추측해본다.</li></ul><br><p>중요한 것은 둘 다 밀리 초로 환산해서 계산하고 있다.</p><br><p>내 맥북에서는 아래와 같이 나왔다</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>❯ exec zsh
15: git
21: zsh-syntax-highlighting
7: zsh-autosuggestions
</code></pre></div><p>21 밀리초면 0.021초라는 말인데, 플러그인은 속도를 느리게 하는 범인이 아닌듯 하다..</p><ul><li>❗️ 시간 측정이 끝나면 시간 측정 코드를 꼭 지우도록 하자!</li></ul><h2 id=-더-확실한-원인을-찾아서>🧭 더 확실한 원인을 찾아서<a hidden class=anchor aria-hidden=true href=#-더-확실한-원인을-찾아서>#</a></h2><p>plugin이 치명적인 원인이 아니므로 zsh이 로드 될 때 일어나는 일들의 시간을 측정해야 한다.</p><p>zsh은 기가막힌 프로파일링 모듈을 가지고 있는데, 이름하여 <a href=http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzprof-Module target=_blank rel=noopener><code>zsh/zprof</code></a>다.</p><p>굉장히 편리하게 사용 할 수 있다. 일단 <code>~/.zshrc</code> 파일을 열어서 제일 첫 문장에 <code>zmodload zsh/zprof</code>를 추가 해준다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>zmodload zsh/zprof
<span style=color:#75715e># If you come from bash you might have to change your $PATH.</span>
<span style=color:#75715e># export PATH=$HOME/bin:/usr/local/bin:$PATH</span>
<span style=color:#75715e># ....</span>
</code></pre></div><p>잘 저장하고 <code>exec zsh</code> 명령어를 사용해서 shell을 다시 실행해준 후 아래와 같은 명령어를 실행하면 프로파일링한 결과를 얻을 수 있다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>❯ zprof
num  calls                time                       self            name
-----------------------------------------------------------------------------------
 1<span style=color:#f92672>)</span>    <span style=color:#ae81ff>3</span>         390.53   130.18   39.51%    390.53   130.18   39.51%  _pyenv_virtualenv_hook
 2<span style=color:#f92672>)</span>    <span style=color:#ae81ff>1</span>         159.78   159.78   16.17%    159.78   159.78   16.17%  compdump
 3<span style=color:#f92672>)</span>    <span style=color:#ae81ff>1</span>         350.09   350.09   35.42%    107.25   107.25   10.85%  compinit
 4<span style=color:#f92672>)</span>  <span style=color:#ae81ff>781</span>          83.97     0.11    8.50%     83.97     0.11    8.50%  compdef
 ....
</code></pre></div><ul><li><em>여기서 <code>compdump</code>, <code>compinit</code>, <code>compdef</code>도 꽤 많은 지분을 가지고 있는데, 잠깐 찾아보니 해당 함수들을 어떻게든 시간 최적화를 한다고 해도 부작용이 일어나지 않을거라는 보장이 없다고 한다. 분하지만 얘네들은 가만히 두자..</em></li></ul><p>참고한 글의 저자는 프로파일링 정보 중 함수 이름 왼쪽에 있는 퍼센트(%) 값이 속도 개선을 하는데 도움이 된다고 한다. 저 퍼센트(%) 값은 쉘 로드 시간 중에 해당 함수가 로드 된 시간의 지분을 뜻한다. (일리 있는 말이다&mldr;!)</p><p>범인을 찾았다! 파이썬 버전과 가상 환경 관리를 편하게 해주는 <a href=https://github.com/pyenv/pyenv target=_blank rel=noopener>pyenv</a>가 날 불편하게 만들고 있었다&mldr;🕵🏻‍♂️</p><h2 id=-가상-환경-관리-툴과-속도-개선-두-마리-토끼-잡기>🔧 가상 환경 관리 툴과 속도 개선 두 마리 토끼 잡기!<a hidden class=anchor aria-hidden=true href=#-가상-환경-관리-툴과-속도-개선-두-마리-토끼-잡기>#</a></h2><p>제일 빠르고 편한 방법은 그냥 pyenv를 지우면 된다. 하지만 고작 1~2초의 이득을 보겠다고 세상 편리한 가상 환경 관리 툴을 지우는건 멍청한 짓이다.</p><p>이제 참고한 글의 저자는 2가지 방법을 제시한다.</p><ol><li>Lazy Loading</li><li><a href=https://blog.mattclemente.com/2020/06/26/oh-my-zsh-slow-to-load.html#caching-eval target=_blank rel=noopener>Caching Eval</a></li></ol><p>개인적인 생각으로 2번째 방법은 caching으로 인해 리소스가 소모되고, 1번 방법보다 시간 최적화가 덜 되어 1번 방법을 선택하기로 했다.(사실 이건 실행하는 환경 관리 툴과 디바이스 별로 다를지도 모른다.) 2번 방법은 참고 글의 링크를 걸었으니, 참고하면 좋을듯 하다.</p><h2 id=-lazy-loading>💤 Lazy Loading<a hidden class=anchor aria-hidden=true href=#-lazy-loading>#</a></h2><p>이 방법이 해결책이 되는 이유는 간단하다. 쉘이 실행 될 때마다 <code>pyenv</code>가 로드 될 필요가 없다는게 포인트다. 안 쓰는데 로드 할 필요가 없지 않은가? 그냥 내가 원할 때 로드해서 사용하면 된다.</p><p>참고 글에서는 저자가 <code>nvm</code>을 사용하기 때문에, <a href=https://github.com/lukechilds/zsh-nvm target=_blank rel=noopener>zsh-nvm</a> 플러그인을 사용해서 해결하는 방법을 보여준다.</p><p>슬프게도 <code>pyenv</code>에게는 <code>zsh-nvm</code> 같이 star가 많은 플러그인이 없다. 그래도 갓갓 개발자분들이 이미 만들어 놓았다. <a href=https://github.com/davidparsson/zsh-pyenv-lazy target=_blank rel=noopener>zsh-pyenv-lazy</a>라는 플러그인인데 파일 설치도 간단하고 코드도 직관적이라 star와 last commit 날짜를 신경쓰지 않고 설치했다.</p><ul><li>저자가 <code>rbenv</code>는 lazy load하는 편한 방법을 못 찾았다고 한다. 그래서 2번 방법을 사용하라고 하는데, <code>zsh-pyenv-lazy</code>처럼 구현 할 수 있지 않을까 하는 조심스러운 추측을 해본다.(내가 만들어볼까?)</li></ul><p>플러그인 설치 후 기존에 입력 해놓은 <code>pyenv</code> 실행 코드를 <code>~/.zshrc</code>에서 삭제했다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#75715e># 혹시 모르니 주석 처리~</span>
<span style=color:#75715e># export PYENV_ROOT=&#34;$HOME/.pyenv&#34;</span>
<span style=color:#75715e># export PATH=&#34;$PYENV_ROOT/bin:$PATH&#34;</span>
<span style=color:#75715e># if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then</span>
<span style=color:#75715e>#   eval &#34;$(pyenv init -)&#34;</span>
<span style=color:#75715e># fi</span>
<span style=color:#75715e># eval &#34;$(pyenv virtualenv-init -)&#34;</span>
</code></pre></div><p>그리고 다시 시간 측정을 하니..!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>❯ <span style=color:#66d9ef>for</span> i in <span style=color:#f92672>{</span>1..5<span style=color:#f92672>}</span>; <span style=color:#66d9ef>do</span> /usr/bin/time $SHELL -i -c exit; <span style=color:#66d9ef>done</span>
        3.24 real         1.77 user         1.44 sys
        2.87 real         1.52 user         1.34 sys
        2.86 real         1.51 user         1.33 sys
        2.87 real         1.51 user         1.34 sys
        2.83 real         1.50 user         1.32 sys
</code></pre></div><p>대략 0.5~0.8초의 시간을 줄였다.(고작..? 현타가 좀 오는데..?)</p><p>뭔가 아직 내가 발견하지 못한 원인들이 있을 것이다. 추후에 다시 한번 연구해봐야겠다.</p><p>그래도 0.8초의 이득과 zsh, shell 문법에 대한 지식을 얻었기 때문에 나름 <strong>성공적</strong>이라고 생각하며 글을 마친다.</p><hr><p><strong>Reference</strong></p><ul><li><p><a href=https://blog.mattclemente.com/2020/06/26/oh-my-zsh-slow-to-load.html#handling-virtual-environments target=_blank rel=noopener>https://blog.mattclemente.com/2020/06/26/oh-my-zsh-slow-to-load.html#handling-virtual-environments</a></p></li><li><p><a href=https://man7.org/linux/man-pages/man1/time.1.html target=_blank rel=noopener>https://man7.org/linux/man-pages/man1/time.1.html</a></p></li><li><p><a href=https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1 target=_blank rel=noopener>https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></p></li><li><p><a href=https://linux.die.net/man/1/zsh target=_blank rel=noopener>https://linux.die.net/man/1/zsh</a></p></li><li><p><a href=https://unix.stackexchange.com/questions/551654/what-does-zshs-i-option-actually-do target=_blank rel=noopener>https://unix.stackexchange.com/questions/551654/what-does-zshs-i-option-actually-do</a></p></li><li><p><a href=https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file target=_blank rel=noopener>https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file</a></p></li><li><p><a href=https://man7.org/linux/man-pages/man1/date.1.html target=_blank rel=noopener>https://man7.org/linux/man-pages/man1/date.1.html</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://callmemaru.com/tags/shell/>shell</a></li><li><a href=https://callmemaru.com/tags/oh-my-zsh/>oh-my-zsh</a></li><li><a href=https://callmemaru.com/tags/zsh/>zsh</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 쉘 로딩 시간 개선하기 on twitter" href="https://twitter.com/intent/tweet/?text=%ec%89%98%20%eb%a1%9c%eb%94%a9%20%ec%8b%9c%ea%b0%84%20%ea%b0%9c%ec%84%a0%ed%95%98%ea%b8%b0&url=https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f&hashtags=shell%2coh-my-zsh%2czsh"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 쉘 로딩 시간 개선하기 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f&title=%ec%89%98%20%eb%a1%9c%eb%94%a9%20%ec%8b%9c%ea%b0%84%20%ea%b0%9c%ec%84%a0%ed%95%98%ea%b8%b0&summary=%ec%89%98%20%eb%a1%9c%eb%94%a9%20%ec%8b%9c%ea%b0%84%20%ea%b0%9c%ec%84%a0%ed%95%98%ea%b8%b0&source=https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 쉘 로딩 시간 개선하기 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f&title=%ec%89%98%20%eb%a1%9c%eb%94%a9%20%ec%8b%9c%ea%b0%84%20%ea%b0%9c%ec%84%a0%ed%95%98%ea%b8%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 쉘 로딩 시간 개선하기 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 쉘 로딩 시간 개선하기 on whatsapp" href="https://api.whatsapp.com/send?text=%ec%89%98%20%eb%a1%9c%eb%94%a9%20%ec%8b%9c%ea%b0%84%20%ea%b0%9c%ec%84%a0%ed%95%98%ea%b8%b0%20-%20https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 쉘 로딩 시간 개선하기 on telegram" href="https://telegram.me/share/url?text=%ec%89%98%20%eb%a1%9c%eb%94%a9%20%ec%8b%9c%ea%b0%84%20%ea%b0%9c%ec%84%a0%ed%95%98%ea%b8%b0&url=https%3a%2f%2fcallmemaru.com%2fposts%2fspeeding-up-my-shell%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"callmemaru"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://callmemaru.com/>Call Me Maru</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>