<!doctype html><html lang=ko dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[정리] 1인 기술 스타트업의 아키텍처 스택 | Call Me Maru</title><meta name=keywords content="글,요약,번역"><meta name=description content="최근에 GeekNews에서 재밌는 글을 봤다. SaaS를 운영하는 1인 개발자가 설계한 아키텍처에 대한 설명인데, GeekNews에 공유해주신 분이 요약 해주신 내용만으로도 굉장히 퀄리티 높은 글인 것을 느낄 수 있었다. 그래서 나도 원문을 읽으며 나름대로 정리를 해볼려고 한다.
참고로 본인이 1인 기술 스타트업을 만들 생각이 없어도 개발자라면 한 번쯤 읽어보면 도움이 되는 글이라고 생각한다.
원문 글: https://anthonynsimon.com/blog/one-man-saas-architecture/
서론


원문 글의 필자는 독일에서 1인 기업을 운영하고 있고 스트레스 없이 자기 자본으로만 천천히 운영하고 있다고 한다.


혼자서 운영하는 만큼 다양한 오픈 소스와 서비스들을 사용하게 되었는데, 이것 없이는 목표를 이룰 수 없었고 이걸 사용함에 있어서 거인의 어깨에 서있는 느낌을 받았다고 한다.(개인적으로 이 표현이 좋았다.)"><meta name=author content="Maru"><link rel=canonical href=https://callmemaru.com/posts/summary-the-architecture-behind-a-one-person-tech-startup/><link crossorigin=anonymous href=/assets/css/stylesheet.42ba59fdd812a780dd1f90061928cf5a041413717731061d8db232e3cf8c61a6.css integrity="sha256-QrpZ/dgSp4DdH5AGGSjPWgQUE3F3MQYdjbIy48+MYaY=" rel="preload stylesheet" as=style><link rel=icon href=https://callmemaru.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://callmemaru.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://callmemaru.com/favicon-32x32.png><link rel=apple-touch-icon href=https://callmemaru.com/favicon-32x32.png><link rel=mask-icon href=https://callmemaru.com/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://callmemaru.com/posts/summary-the-architecture-behind-a-one-person-tech-startup/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://callmemaru.com/posts/summary-the-architecture-behind-a-one-person-tech-startup/"><meta property="og:site_name" content="Call Me Maru"><meta property="og:title" content="[정리] 1인 기술 스타트업의 아키텍처 스택"><meta property="og:description" content="최근에 GeekNews에서 재밌는 글을 봤다. SaaS를 운영하는 1인 개발자가 설계한 아키텍처에 대한 설명인데, GeekNews에 공유해주신 분이 요약 해주신 내용만으로도 굉장히 퀄리티 높은 글인 것을 느낄 수 있었다. 그래서 나도 원문을 읽으며 나름대로 정리를 해볼려고 한다.
참고로 본인이 1인 기술 스타트업을 만들 생각이 없어도 개발자라면 한 번쯤 읽어보면 도움이 되는 글이라고 생각한다.
원문 글: https://anthonynsimon.com/blog/one-man-saas-architecture/
서론 원문 글의 필자는 독일에서 1인 기업을 운영하고 있고 스트레스 없이 자기 자본으로만 천천히 운영하고 있다고 한다.
혼자서 운영하는 만큼 다양한 오픈 소스와 서비스들을 사용하게 되었는데, 이것 없이는 목표를 이룰 수 없었고 이걸 사용함에 있어서 거인의 어깨에 서있는 느낌을 받았다고 한다.(개인적으로 이 표현이 좋았다.)"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-24T14:34:02+09:00"><meta property="article:modified_time" content="2021-04-24T14:34:02+09:00"><meta property="article:tag" content="글"><meta property="article:tag" content="요약"><meta property="article:tag" content="번역"><meta property="og:image" content="https://callmemaru.com/og_image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://callmemaru.com/og_image.png"><meta name=twitter:title content="[정리] 1인 기술 스타트업의 아키텍처 스택"><meta name=twitter:description content="최근에 GeekNews에서 재밌는 글을 봤다. SaaS를 운영하는 1인 개발자가 설계한 아키텍처에 대한 설명인데, GeekNews에 공유해주신 분이 요약 해주신 내용만으로도 굉장히 퀄리티 높은 글인 것을 느낄 수 있었다. 그래서 나도 원문을 읽으며 나름대로 정리를 해볼려고 한다.
참고로 본인이 1인 기술 스타트업을 만들 생각이 없어도 개발자라면 한 번쯤 읽어보면 도움이 되는 글이라고 생각한다.
원문 글: https://anthonynsimon.com/blog/one-man-saas-architecture/
서론


원문 글의 필자는 독일에서 1인 기업을 운영하고 있고 스트레스 없이 자기 자본으로만 천천히 운영하고 있다고 한다.


혼자서 운영하는 만큼 다양한 오픈 소스와 서비스들을 사용하게 되었는데, 이것 없이는 목표를 이룰 수 없었고 이걸 사용함에 있어서 거인의 어깨에 서있는 느낌을 받았다고 한다.(개인적으로 이 표현이 좋았다.)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://callmemaru.com/posts/"},{"@type":"ListItem","position":2,"name":"[정리] 1인 기술 스타트업의 아키텍처 스택","item":"https://callmemaru.com/posts/summary-the-architecture-behind-a-one-person-tech-startup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[정리] 1인 기술 스타트업의 아키텍처 스택","name":"[정리] 1인 기술 스타트업의 아키텍처 스택","description":"최근에 GeekNews에서 재밌는 글을 봤다. SaaS를 운영하는 1인 개발자가 설계한 아키텍처에 대한 설명인데, GeekNews에 공유해주신 분이 요약 해주신 내용만으로도 굉장히 퀄리티 높은 글인 것을 느낄 수 있었다. 그래서 나도 원문을 읽으며 나름대로 정리를 해볼려고 한다.\n참고로 본인이 1인 기술 스타트업을 만들 생각이 없어도 개발자라면 한 번쯤 읽어보면 도움이 되는 글이라고 생각한다.\n원문 글: https://anthonynsimon.com/blog/one-man-saas-architecture/\n서론 원문 글의 필자는 독일에서 1인 기업을 운영하고 있고 스트레스 없이 자기 자본으로만 천천히 운영하고 있다고 한다.\n혼자서 운영하는 만큼 다양한 오픈 소스와 서비스들을 사용하게 되었는데, 이것 없이는 목표를 이룰 수 없었고 이걸 사용함에 있어서 거인의 어깨에 서있는 느낌을 받았다고 한다.(개인적으로 이 표현이 좋았다.)\n","keywords":["글","요약","번역"],"articleBody":"최근에 GeekNews에서 재밌는 글을 봤다. SaaS를 운영하는 1인 개발자가 설계한 아키텍처에 대한 설명인데, GeekNews에 공유해주신 분이 요약 해주신 내용만으로도 굉장히 퀄리티 높은 글인 것을 느낄 수 있었다. 그래서 나도 원문을 읽으며 나름대로 정리를 해볼려고 한다.\n참고로 본인이 1인 기술 스타트업을 만들 생각이 없어도 개발자라면 한 번쯤 읽어보면 도움이 되는 글이라고 생각한다.\n원문 글: https://anthonynsimon.com/blog/one-man-saas-architecture/\n서론 원문 글의 필자는 독일에서 1인 기업을 운영하고 있고 스트레스 없이 자기 자본으로만 천천히 운영하고 있다고 한다.\n혼자서 운영하는 만큼 다양한 오픈 소스와 서비스들을 사용하게 되었는데, 이것 없이는 목표를 이룰 수 없었고 이걸 사용함에 있어서 거인의 어깨에 서있는 느낌을 받았다고 한다.(개인적으로 이 표현이 좋았다.)\n상황에 따라 기술적 선택은 다르다. 이 글은 본인이 선택한 기술들을 공유하는 것 뿐이니, 진리라고 생각하지 말자.\n글쓴이는 AWS에서 Kubernetes를 사용하는데, 이것은 단지 이전 회사와 팀에서 몇 년동안 삽질을 하며 내공을 쌓았기 때문에 쓴 것이다. 이 글을 보는 사람들은 자신에게 익숙한 기술을 사용해서 생산성을 저하시키는 방향을 가지 않도록 하자.\n프로젝트의 구조 글쓴이가 만든 PanelBear라는 서비스로 프로젝트 구조를 설명함.\ndjango monolith 구조, app DB는 Postgres, analytics data는 ClickHouse, 캐싱은 Redis, 테스크 스케줄링은 Celery를 사용하고 쿠버네티스(EKS)에서 운영\nMonolithic 구조이므로 Django는 Rails나 Laravel 등으로 대체 가능하다.\n여기서 흥미로운 부분은 autoscaling, ingress, TLS certificates, failover, logging, monitoring 같은 것들이 서로 결합되고 자동화 되는 부분이다.\n이 세팅은 다양한 프로젝트에서 사용했다. 이 세팅 덕분에 비용을 줄이고 검증을 쉽게 할 수 있었다.(Dockerfile을 작성하고 git push만 하면 된다.)\n실제로 인프라를 관리하는 시간은 한 달에 0~2시간 뿐이다. 덕분에 피처 개발, CS, 사업의 성장에 집중 할 수 있었다.\n“Kubernetes makes the simple stuff complex, but it also makes the complex stuff simpler”\nAutomatic DNS, SSL, and Load Balancing 첫 번쨰 주제: 클러스터에서 트래픽을 어떻게 받을 것인가?\n클러스터는 private 네트워크에 있다.\nNLB(AWS L4 Network Load Balancer)로 트래픽을 향하게 하는 Cloudflare proxying이 존재한다. 이 로드 밸런서는 public internet과 private network의 브릿지 역할을 한다.\n요청이 들어오면 로드밸러스가 쿠버네티스 클러스터 노드 중 하나로 포워드한다.\ningress-nginx를 사용해서 쿠버네티스가 어느 서비스로 포워드 할지 정해준다. ingress-nginx는 클러스터의 입구다.\nNGINX는 요청을 일치하는 컨테이너(해당 글에서는 Uvicorn으로 서빙되는 django)로 전달하기 전에 rate-limiting과 traffic shaping 규칙을 적용한다.\n몇 개의 terraform/kubernetes 파일로 전체 프로젝트에 적용 가능하기 때문에 한 번 설정하고 잊어버릴 수 있다.\n새로운 프로젝트를 배포 할 때, 필수적인 설정을 20줄만 적어주면 된다.\napiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: namespace: example name: example-api annotations: kubernetes.io/ingress.class: \"nginx\" nginx.ingress.kubernetes.io/limit-rpm: \"5000\" cert-manager.io/cluster-issuer: \"letsencrypt-prod\" external-dns.alpha.kubernetes.io/cloudflare-proxied: \"true\" spec: tls: - hosts: - api.example.com secretName: example-api-tls rules: - host: api.example.com http: paths: - path: / backend: serviceName: example-api servicePort: http Automated rollouts and rollbacks GitHub의 마스터 브랜치에 프로젝트를 push하면 GitHub Actions의 CI 파이프라인이 실행 된다.\nCI 파이프라인은 아래와 같은 과정을 거친다.\n코드베이스로 체크한다.(Format, Lint, Check types) Docker-compose로 완벽한 환경을 만들어서 end-to-end test를 거친다. 1, 2번이 통과되면 새로운 Docker image를 만들어서 ECR로 push 한다. ECR로 push 되면 flux라는 컴포넌트가 현재 클러스터에서 실행되고 있는 이미지와 최근 등록된 이미지를 동기화 시켜준다.\nFlux는 새로운 Docker image가 생겼을 때 자동으로 incremental rollout을 하고 “Infrastructure Monorepo\"에 기록한다.\nLet it crash 쿠버네티스는 비정상 적인 pod이 고쳐질 동안 트래픽을 정상적인 pod으로 옮기는 것에 뛰어나다. Horizontal autoscaling 컨테이너들은 CPU와 Memory 사용량에 따라 오토스케일링 된다.\n노드당 많은 Pods이 클러스터에 생기면 자동적으로 클러스터 용량을 늘리고, 아닐 경우 축소한다.\n오토스케일링은 아래와 같이 한다\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: panelbear-api namespace: panelbear spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: panelbear-api minReplicas: 2 maxReplicas: 8 targetCPUUtilizationPercentage: 50 PanelBear는 API pod을 CPU 사용량에 따라 2개에서 9개로 복제본을 조정한다.\nStatic assets cached by CDN Cloudflare를 사용해서 DNS, 그리고 요청에 대한 CDN, DDoS 보호를 함.\n단순하게 HTTP cache headers를 사용해서 Cloudflare 캐시를 컨트롤 하게 한다.\n# Cache this response for 5 minutes response[\"Cache-Control\"] = \"public, max-age=300\" Whitenoise를 사용해서 app container로 부터 정적 파일을 서빙한다.\n이걸 사용하면 Nginx/Cloudfront/S3에 정적파일을 업로드 할 필요가 없어서 간단하다.\n지금까지 이런 방식은 문제가 없었고 성능도 뛰어나면서 간단했다.\n정적 웹사이트로는 NextJS를 사용했다. Cloudfront/S3 또는 Netlify/Vercel을 통해 서빙 할 수도 있지만, 클러스터의 하나의 컨테이너로 실행되게 하고 정적 assets을 Cloudflare에 캐싱하는게 더 쉬웠다.\nApplication data caching 파이썬에서 제공하는 LRU(Least Recently Used) cache를 사용해서 네트워크 콜을 제로로 할 수 있었다.\n대부분의 endpoints는 인 클러스터 Redis로 캐싱 했다. Redis는 모든 Django instance가 공유 했다. 인스턴스가 재배포 되면 메모리 캐시를 모두 지웠다.\nPer endpoint rate-limiting Kubernetes의 nginx-ingress로 전역적인 rate limits를 설정하긴 했지만, 특정 endpoint나 메서드에도 limit을 설정하기 위해 Django Ratelimit 라이브러리를 사용했다.\nuser의 ip를 각 request에 따라 Redis에 저장해서 조건에 맞게 요청을 제한한다. 아래 예제는 한 유저가 1분에 요청을 5번 넘게 보내면 HTTP 429 Too Many Requests status 상태 코드를 반환하는 예제이다\nclass MySensitiveActionView(RatelimitMixin, LoginRequiredMixin): ratelimit_key = \"user_or_ip\" ratelimit_rate = \"5/m\" ratelimit_method = \"POST\" ratelimit_block = True def get(): ... def post(): ... App administration Django가 기본으로 제공해주는 admin을 사용합니다. Running scheduled jobs 고객용 데일리 리포트, 15분 마다 사용 통계 계산, 스태프용 이메일 보내기 등 다양한 예약 작업이 있다.\nCelery workers와 Celery beat를 cluster에서 실행한다. Task queue로는 Redis를 사용한다.\n만약 예약 된 작업이 정상적으로 작동하지 않으면 Healthchecks를 통해 slack/sms/email로 알림을 받는다.\n아래는 예약 된 작업의 상태를 체크하는 모니터링 코드다.\ndef some_hourly_job(): # Task logic ... # Ping monitoring service once task completes TaskMonitor( name=\"send_quota_depleted_email\", expected_schedule=timedelta(hours=1), grace_period=timedelta(hours=2), ).ping() App configuration 쿠버네티스의 configmap을 사용하여 환경 변수를 오버라이딩하고 django의 settings.py에 환경 변수를 정의 한다. apiVersion: v1 kind: ConfigMap metadata: namespace: panelbear name: panelbear-webserver-config data: INVITE_ONLY: \"True\" DEFAULT_FROM_EMAIL: \"The Panelbear Team \" SESSION_COOKIE_SECURE: \"True\" SECURE_HSTS_PRELOAD: \"True\" SECURE_SSL_REDIRECT: \"True\" INVITE_ONLY = env.str(\"INVITE_ONLY\", default=False) Keeping secrets 쿠버네티스의 kubeseal을 사용해서 키들을 암호화한다. kubeseal은 비대칭 암호화를 한다. 그리고 오직 클러스터만 복호화 키에 접근할 권한을 가지고 있다. 암호화하면 아래와 같이 보인다.\napiVersion: bitnami.com/v1alpha1 kind: SealedSecret metadata: name: panelbear-secrets namespace: panelbear spec: encryptedData: DATABASE_CONN_URL: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq... SESSION_COOKIE_SECRET: oi7ySY1ZA9rO43cGDEq+ygByri4OJBlK...... 클러스터 안의 Secret을 보호하기 위해 AWS KMS을 사용한다. 쿠버네티스 클러스터를 생성할 때 세팅한다.\n과정을 나타내면 아래와 같다.\n암호화 할 환경 변수를 쿠버네티스 manifest에 작성한다. 커밋하기 전에 암호화를 하고 푸시한다. 암호화 된 변수는 배포되고, 클러스터는 자동으로 컨테이너를 실행하기 전에 암호화 된 변수를 복호화 한다. Relational data: Postgres 처음에는 바닐라 postgres 컨테이너를 쿠버네티스 클러스터에서 실행했다.\n프로젝트가 성장함에 따라 AWS RDS로 이전했다.\nRDS를 사용함으로써 지속적인 보안 업데이트, 암호화 된 백업 같은 장점을 누릴 수 있었다.\nColumnar data: ClickHouse 프로젝트의 분석 데이터를 실시간으로 쿼리하고 효율적이게 저장하기 위해 ClickHouse를 이용했다.\n이 서비스는 엄청 빠르고, 데이터 구조를 잘 잡음으로써 압축률만 잘 잡으면 저장 비용이 낮아짐. 이건 수익률을 높임.\n현재 ClickHouse 인스턴스를 쿠버네티스 클러스터에 호스트해서 사용하고 있다.\n쿠버네티스 CronJob을 사용해서 주기적으로 효율적인 columnar format으로 백업한 데이터를 S3로 보냄.\n재난 상황이 일어났을 때 복원 할 수 있게 스크립트를 짜놓음\n유일하게 써보지 않은 툴이였는데, 문서가 잘 정리되어 있어서 금방 사용하게 됨.\nDNS-based service discovery 각 컨테이너끼리 쿠버네티스 내에서 서로 통신은 DNS 레코드 기반으로 이루어진다.\nredis://redis.weekend-project.svc.cluster:6379 DNS 레코드는 쿠버네티스가 자동으로 관리한다.\n쿠버네티스는 자동으로 DNS 레코드를 건강한 Pod으로 동기화 한다.\n위의 내용의 원리를 알고 싶으면, 잘 설명하고 있는 글 하나를 추천한다.\nVersion-controlled infrastructure version-controlled를 간단한 커맨드로 하고 싶어서 Docker, Terraform 그리고 Kubernetes manifest를 하나의 레포에 두었다.\n이 레포는 여러 프로젝트에 대한 인프라를 가지고 있다. 즉, 여러 프로젝트들은 서로 다른 레포에 저장되어 있지만, 각 프로젝트의 인프라에 대한 관리는 이 단일 레포에서 하는 것이다.\nThe Twelve-Factor App에 대해 알고 있다면 이 구조가 꽤 괜찮아 보일 것이다.\n이렇게 해서 단순한 커맨드로 인프라로 관리할 수 있게 되었다. 아래는 인프라 단일 레포의 구조를 예시로 나타냈다.\n# Cloud resources terraform/ aws/ rds.tf ecr.tf eks.tf lambda.tf s3.tf roles.tf vpc.tf cloudflare/ projects.tf # Kubernetes manifests manifests/ cluster/ ingress-nginx/ external-dns/ certmanager/ monitoring/ apps/ panelbear/ webserver.yaml celery-scheduler.yaml celery-workers.yaml secrets.encrypted.yaml ingress.yaml redis.yaml clickhouse.yaml another-saas/ my-weekend-project/ some-ghost-blog/ # Python scripts for disaster recovery, and CI tasks/ ... # In case of a fire, some help for future me README.md DISASTER.md TROUBLESHOOTING.md Terraform for cloud resources Terraform을 사용해서 대부분의 클라우드 리소스를 관리한다.\n문서화와 리소스를 추적하고 인프라를 설정하는 것에 도움을 주었다.\nKubernetes manifests for app deployments 쿠버네티스 manifest들은 모든 YAML 파일로 기술되어 있고 인프라 단일 레포에 위치해 있다.\n두 개의 레포로 분리 했다: cluster \u0026 app\ncluster 디렉토리 안에는 nginx-ingress, encryped secrets, premotheus scaper 같은 클러스터 전체 서비스의 설정에 대한 내용이 있다.\napp 디렉토리 안에는 프로젝트와 관련된 내용이 있다.\nSubscriptions and Payments Stripe Checkout으로 결제 기능을 관리한다.\n결제 정보에 접근할 필요가 없으므로 프로덕트 개발에 더 집중할 수 있게 됐다.\n새로운 고객 세션을 만든 뒤 Stripe가 호스트한 페이지로 리다이렉트 시킨 후 webhook을 통해 결제의 결과에 따라 나의 데이터베이스를 업데이트 하기만 하면 된다.\n물론 webhook과 관련되서 중요한 부분이 있지만, Strip 문서가 잘 다뤄주고 있다.\nLogging logging을 하기 위해 특별한 agent 같은 건 사용하지 않음.\nstdout을 통해 찍힌 로그를 쿠버네티스가 자동으로 수집하게 하고, 로그를 rotate 함.\nElasticSearch/Kibana 같은 자동으로 로그를 모아주는 툴을 쓸 수도 있지만, 지금은 간단하게 유지하고 싶어함.\n로그를 추적하기 위해 쿠버네티스 CLI 툴인 stern을 사용함.\nMonitoring and alerting 처음에는 Prometheus/Grafana를 자체 호스팅해서 클러스터와 애플리케이션 수치를 모니터링 했다.\n하지만 클러스터가 문제가 생기면 모니터링 툴의 alerting system도 다운되서 좋지 않다고 느꼈다.\n그래서 New Relic로 툴을 변경했다.\n클러스터 내의 모든 서비스는 Prometheus integration을 가지고 있어서 자동으로 기록을 New Relic으로 보낼 수 있었다. 그래서 New Relic으로 마이그레이션 할 때 단순히 Prometheus Docker image만 사용하면 됐었다.\n장고 앱의 수치를 기록하는 방법으로는 django-prometheus 라이브러리를 사용했다.\nError tracking Error tracking 툴로는 Sentry를 사용했다.\n장고 앱에서 샌트리를 사용하는 방법은 간단하다.\nSENTRY_DSN = env.str(\"SENTRY_DSN\", default=None) # Init Sentry if configured if SENTRY_DSN: sentry_sdk.init( dsn=SENTRY_DSN, integrations=[DjangoIntegration(), RedisIntegration(), CeleryIntegration()], # Do not send user PII data to Sentry # See also inbound rules for special patterns send_default_pii=False, # Only sample a small amount of performance traces traces_sample_rate=env.float(\"SENTRY_TRACES_SAMPLE_RATE\", default=0.008), ) 또한 Slack #alerts 채널을 사용해서 모든 알림(downtime, cron job failures, security alerts, performance regressions, application exceptions, and whatnot.)을 이 채널로 오도록 했다.\nProfiling and other goodies cProfile, snakeviz, Django debug toolbar를 통해 profiling을 했다. 마치면서 (개인적인 생각) 저자도 앞에서 언급한 것과 같이 위에서 소개 된 도구와 방법은 정답이 아니다. 각자의 상황 또는 프로젝트의 특성에 따라 정답은 바뀔 수 있다.\n그러나 프로젝트가 진행 될 때 공통적으로 필요한 기능들은 위에서 대부분 언급했고 그에 대한 하나의 선택지를 알려줬다고 생각한다.\n이 글을 쓰는 나를 포함해서 글을 읽는 여러분들이, 원문의 저자가 공유해준 경험과 선택지를 참고 삼아 자신만의 정답을 찾았으면 좋겠다.\nReference\nhttps://anthonynsimon.com/blog/one-man-saas-architecture/ ","wordCount":"1566","inLanguage":"ko","image":"https://callmemaru.com/og_image.png","datePublished":"2021-04-24T14:34:02+09:00","dateModified":"2021-04-24T14:34:02+09:00","author":[{"@type":"Person","name":"Maru"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://callmemaru.com/posts/summary-the-architecture-behind-a-one-person-tech-startup/"},"publisher":{"@type":"Organization","name":"Call Me Maru","logo":{"@type":"ImageObject","url":"https://callmemaru.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://callmemaru.com/ accesskey=h title="Call Me Maru (Alt + H)">Call Me Maru</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://callmemaru.com/about/ title=About><span>About</span></a></li><li><a href=https://callmemaru.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[정리] 1인 기술 스타트업의 아키텍처 스택</h1><div class=post-meta><span title='2021-04-24 14:34:02 +0900 +0900'>2021년 4월 24일</span>&nbsp;·&nbsp;<span>8 분</span>&nbsp;·&nbsp;<span>Maru</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%84%9c%eb%a1%a0 aria-label=서론>서론</a></li><li><a href=#%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="프로젝트의 구조">프로젝트의 구조</a></li><li><a href=#automatic-dns-ssl-and-load-balancing aria-label="Automatic DNS, SSL, and Load Balancing">Automatic DNS, SSL, and Load Balancing</a></li><li><a href=#automated-rollouts-and-rollbacks aria-label="Automated rollouts and rollbacks">Automated rollouts and rollbacks</a></li><li><a href=#let-it-crash aria-label="Let it crash">Let it crash</a></li><li><a href=#horizontal-autoscaling aria-label="Horizontal autoscaling">Horizontal autoscaling</a></li><li><a href=#static-assets-cached-by-cdn aria-label="Static assets cached by CDN">Static assets cached by CDN</a></li><li><a href=#application-data-caching aria-label="Application data caching">Application data caching</a></li><li><a href=#per-endpoint-rate-limiting aria-label="Per endpoint rate-limiting">Per endpoint rate-limiting</a></li><li><a href=#app-administration aria-label="App administration">App administration</a></li><li><a href=#running-scheduled-jobs aria-label="Running scheduled jobs">Running scheduled jobs</a></li><li><a href=#app-configuration aria-label="App configuration">App configuration</a></li><li><a href=#keeping-secrets aria-label="Keeping secrets">Keeping secrets</a></li><li><a href=#relational-data-postgres aria-label="Relational data: Postgres">Relational data: Postgres</a></li><li><a href=#columnar-data-clickhouse aria-label="Columnar data: ClickHouse">Columnar data: ClickHouse</a></li><li><a href=#dns-based-service-discovery aria-label="DNS-based service discovery">DNS-based service discovery</a></li><li><a href=#version-controlled-infrastructure aria-label="Version-controlled infrastructure">Version-controlled infrastructure</a></li><li><a href=#terraform-for-cloud-resources aria-label="Terraform for cloud resources">Terraform for cloud resources</a></li><li><a href=#kubernetes-manifests-for-app-deployments aria-label="Kubernetes manifests for app deployments">Kubernetes manifests for app deployments</a></li><li><a href=#subscriptions-and-payments aria-label="Subscriptions and Payments">Subscriptions and Payments</a></li><li><a href=#logging aria-label=Logging>Logging</a></li><li><a href=#monitoring-and-alerting aria-label="Monitoring and alerting">Monitoring and alerting</a></li><li><a href=#error-tracking aria-label="Error tracking">Error tracking</a></li><li><a href=#profiling-and-other-goodies aria-label="Profiling and other goodies">Profiling and other goodies</a></li><li><a href=#%eb%a7%88%ec%b9%98%eb%a9%b4%ec%84%9c-%ea%b0%9c%ec%9d%b8%ec%a0%81%ec%9d%b8-%ec%83%9d%ea%b0%81 aria-label="마치면서 (개인적인 생각)">마치면서 (개인적인 생각)</a></li></ul></div></details></div><div class=post-content><p>최근에 <a href=https://news.hada.io/ target=_blank rel=noopener>GeekNews</a>에서 <a href="https://news.hada.io/topic?id=4055" target=_blank rel=noopener>재밌는 글</a>을 봤다. SaaS를 운영하는 1인 개발자가 설계한 아키텍처에 대한 설명인데, GeekNews에 공유해주신 분이 요약 해주신 내용만으로도 굉장히 퀄리티 높은 글인 것을 느낄 수 있었다. 그래서 나도 원문을 읽으며 나름대로 정리를 해볼려고 한다.</p><p>참고로 본인이 1인 기술 스타트업을 만들 생각이 없어도 개발자라면 한 번쯤 읽어보면 도움이 되는 글이라고 생각한다.</p><p><strong>원문 글: <a href=https://anthonynsimon.com/blog/one-man-saas-architecture/ target=_blank rel=noopener>https://anthonynsimon.com/blog/one-man-saas-architecture/</a></strong></p><h2 id=서론>서론<a hidden class=anchor aria-hidden=true href=#서론>#</a></h2><ul><li><p>원문 글의 필자는 독일에서 1인 기업을 운영하고 있고 스트레스 없이 자기 자본으로만 천천히 운영하고 있다고 한다.</p></li><li><p>혼자서 운영하는 만큼 다양한 오픈 소스와 서비스들을 사용하게 되었는데, 이것 없이는 목표를 이룰 수 없었고 이걸 사용함에 있어서 거인의 어깨에 서있는 느낌을 받았다고 한다.(개인적으로 이 표현이 좋았다.)</p></li><li><p><em>상황에 따라 기술적 선택은 다르다.</em> 이 글은 본인이 선택한 기술들을 공유하는 것 뿐이니, <strong>진리라고 생각하지 말자.</strong></p></li><li><p>글쓴이는 AWS에서 Kubernetes를 사용하는데, 이것은 단지 이전 회사와 팀에서 몇 년동안 삽질을 하며 내공을 쌓았기 때문에 쓴 것이다. 이 글을 보는 사람들은 자신에게 익숙한 기술을 사용해서 생산성을 저하시키는 방향을 가지 않도록 하자.</p></li></ul><h2 id=프로젝트의-구조>프로젝트의 구조<a hidden class=anchor aria-hidden=true href=#프로젝트의-구조>#</a></h2><ul><li><p>글쓴이가 만든 <a href=https://panelbear.com/ target=_blank rel=noopener>PanelBear</a>라는 서비스로 프로젝트 구조를 설명함.</p></li><li><p>django monolith 구조, app DB는 Postgres, analytics data는 ClickHouse, 캐싱은 Redis, 테스크 스케줄링은 Celery를 사용하고 쿠버네티스(EKS)에서 운영</p></li><li><p>Monolithic 구조이므로 Django는 Rails나 Laravel 등으로 대체 가능하다.</p></li><li><p>여기서 흥미로운 부분은 autoscaling, ingress, TLS certificates, failover, logging, monitoring 같은 것들이 서로 결합되고 자동화 되는 부분이다.</p></li><li><p>이 세팅은 다양한 프로젝트에서 사용했다. 이 세팅 덕분에 비용을 줄이고 검증을 쉽게 할 수 있었다.(Dockerfile을 작성하고 git push만 하면 된다.)</p></li><li><p>실제로 인프라를 관리하는 시간은 한 달에 0~2시간 뿐이다. 덕분에 피처 개발, CS, 사업의 성장에 집중 할 수 있었다.</p></li><li><p><em>&ldquo;Kubernetes makes the simple stuff complex, but it also makes the complex stuff simpler&rdquo;</em></p></li></ul><h2 id=automatic-dns-ssl-and-load-balancing>Automatic DNS, SSL, and Load Balancing<a hidden class=anchor aria-hidden=true href=#automatic-dns-ssl-and-load-balancing>#</a></h2><ul><li><p>첫 번쨰 주제: 클러스터에서 트래픽을 어떻게 받을 것인가?</p></li><li><p>클러스터는 private 네트워크에 있다.</p></li><li><p>NLB(AWS L4 Network Load Balancer)로 트래픽을 향하게 하는 Cloudflare proxying이 존재한다. 이 로드 밸런서는 public internet과 private network의 브릿지 역할을 한다.</p></li><li><p>요청이 들어오면 로드밸러스가 쿠버네티스 클러스터 노드 중 하나로 포워드한다.</p></li><li><p><a href=https://github.com/kubernetes/ingress-nginx target=_blank rel=noopener>ingress-nginx</a>를 사용해서 쿠버네티스가 어느 서비스로 포워드 할지 정해준다. ingress-nginx는 클러스터의 입구다.</p></li><li><p>NGINX는 요청을 일치하는 컨테이너(해당 글에서는 Uvicorn으로 서빙되는 django)로 전달하기 전에 rate-limiting과 traffic shaping 규칙을 적용한다.</p></li><li><p>몇 개의 terraform/kubernetes 파일로 전체 프로젝트에 적용 가능하기 때문에 한 번 설정하고 잊어버릴 수 있다.</p></li><li><p>새로운 프로젝트를 배포 할 때, 필수적인 설정을 20줄만 적어주면 된다.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>example</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-api</span>
</span></span><span style=display:flex><span><span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>kubernetes.io/ingress.class</span>: <span style=color:#e6db74>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>nginx.ingress.kubernetes.io/limit-rpm</span>: <span style=color:#e6db74>&#34;5000&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>cert-manager.io/cluster-issuer</span>: <span style=color:#e6db74>&#34;letsencrypt-prod&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>external-dns.alpha.kubernetes.io/cloudflare-proxied</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>tls</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>hosts</span>:
</span></span><span style=display:flex><span>   - <span style=color:#ae81ff>api.example.com</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>secretName</span>: <span style=color:#ae81ff>example-api-tls</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>host</span>: <span style=color:#ae81ff>api.example.com</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>   <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>     - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>         <span style=color:#f92672>serviceName</span>: <span style=color:#ae81ff>example-api</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>servicePort</span>: <span style=color:#ae81ff>http</span>
</span></span></code></pre></div><h2 id=automated-rollouts-and-rollbacks>Automated rollouts and rollbacks<a hidden class=anchor aria-hidden=true href=#automated-rollouts-and-rollbacks>#</a></h2><ul><li><p>GitHub의 마스터 브랜치에 프로젝트를 push하면 GitHub Actions의 CI 파이프라인이 실행 된다.</p></li><li><p>CI 파이프라인은 아래와 같은 과정을 거친다.</p><ol><li>코드베이스로 체크한다.(Format, Lint, Check types)</li><li>Docker-compose로 완벽한 환경을 만들어서 end-to-end test를 거친다.</li><li>1, 2번이 통과되면 새로운 Docker image를 만들어서 <a href=https://aws.amazon.com/ko/ecr/ target=_blank rel=noopener>ECR</a>로 push 한다.</li></ol></li><li><p>ECR로 push 되면 <a href=https://fluxcd.io/ target=_blank rel=noopener>flux</a>라는 컴포넌트가 현재 클러스터에서 실행되고 있는 이미지와 최근 등록된 이미지를 동기화 시켜준다.</p></li><li><p>Flux는 새로운 Docker image가 생겼을 때 자동으로 incremental rollout을 하고 &ldquo;Infrastructure Monorepo"에 기록한다.</p></li></ul><h2 id=let-it-crash>Let it crash<a hidden class=anchor aria-hidden=true href=#let-it-crash>#</a></h2><ul><li>쿠버네티스는 비정상 적인 pod이 고쳐질 동안 트래픽을 정상적인 pod으로 옮기는 것에 뛰어나다.</li></ul><h2 id=horizontal-autoscaling>Horizontal autoscaling<a hidden class=anchor aria-hidden=true href=#horizontal-autoscaling>#</a></h2><ul><li><p>컨테이너들은 CPU와 Memory 사용량에 따라 오토스케일링 된다.</p></li><li><p>노드당 많은 Pods이 클러스터에 생기면 자동적으로 클러스터 용량을 늘리고, 아닐 경우 축소한다.</p></li><li><p>오토스케일링은 아래와 같이 한다</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>autoscaling/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>HorizontalPodAutoscaler</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>panelbear-api</span>
</span></span><span style=display:flex><span><span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>panelbear</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>scaleTargetRef</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>panelbear-api</span>
</span></span><span style=display:flex><span><span style=color:#f92672>minReplicas</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>maxReplicas</span>: <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#f92672>targetCPUUtilizationPercentage</span>: <span style=color:#ae81ff>50</span>
</span></span></code></pre></div></li><li><p>PanelBear는 API pod을 CPU 사용량에 따라 2개에서 9개로 복제본을 조정한다.</p></li></ul><h2 id=static-assets-cached-by-cdn>Static assets cached by CDN<a hidden class=anchor aria-hidden=true href=#static-assets-cached-by-cdn>#</a></h2><ul><li><p>Cloudflare를 사용해서 DNS, 그리고 요청에 대한 CDN, DDoS 보호를 함.</p></li><li><p>단순하게 HTTP cache headers를 사용해서 Cloudflare 캐시를 컨트롤 하게 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Cache this response for 5 minutes</span>
</span></span><span style=display:flex><span>response[<span style=color:#e6db74>&#34;Cache-Control&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;public, max-age=300&#34;</span>
</span></span></code></pre></div></li><li><p><a href=https://github.com/evansd/whitenoise target=_blank rel=noopener>Whitenoise</a>를 사용해서 app container로 부터 정적 파일을 서빙한다.</p></li><li><p>이걸 사용하면 Nginx/Cloudfront/S3에 정적파일을 업로드 할 필요가 없어서 간단하다.</p></li><li><p>지금까지 이런 방식은 문제가 없었고 성능도 뛰어나면서 간단했다.</p></li><li><p>정적 웹사이트로는 NextJS를 사용했다. Cloudfront/S3 또는 Netlify/Vercel을 통해 서빙 할 수도 있지만, 클러스터의 하나의 컨테이너로 실행되게 하고 정적 assets을 Cloudflare에 캐싱하는게 더 쉬웠다.</p></li></ul><h2 id=application-data-caching>Application data caching<a hidden class=anchor aria-hidden=true href=#application-data-caching>#</a></h2><ul><li><p>파이썬에서 제공하는 <a href=https://docs.python.org/3/library/functools.html#functools.lru_cache target=_blank rel=noopener>LRU(Least Recently Used)</a> cache를 사용해서 네트워크 콜을 제로로 할 수 있었다.</p></li><li><p>대부분의 endpoints는 인 클러스터 Redis로 캐싱 했다. Redis는 모든 Django instance가 공유 했다. 인스턴스가 재배포 되면 메모리 캐시를 모두 지웠다.</p></li></ul><h2 id=per-endpoint-rate-limiting>Per endpoint rate-limiting<a hidden class=anchor aria-hidden=true href=#per-endpoint-rate-limiting>#</a></h2><ul><li><p>Kubernetes의 nginx-ingress로 전역적인 rate limits를 설정하긴 했지만, 특정 endpoint나 메서드에도 limit을 설정하기 위해 <a href=https://django-ratelimit.readthedocs.io/en/stable/ target=_blank rel=noopener>Django Ratelimit</a> 라이브러리를 사용했다.</p></li><li><p>user의 ip를 각 request에 따라 Redis에 저장해서 조건에 맞게 요청을 제한한다. 아래 예제는 한 유저가 1분에 요청을 5번 넘게 보내면 <code>HTTP 429 Too Many Requests status</code> 상태 코드를 반환하는 예제이다</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MySensitiveActionView</span>(RatelimitMixin, LoginRequiredMixin):
</span></span><span style=display:flex><span>    ratelimit_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;user_or_ip&#34;</span>
</span></span><span style=display:flex><span>    ratelimit_rate <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;5/m&#34;</span>
</span></span><span style=display:flex><span>    ratelimit_method <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;POST&#34;</span>
</span></span><span style=display:flex><span>    ratelimit_block <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get</span>():
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>post</span>():
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span></code></pre></div></li></ul><h2 id=app-administration>App administration<a hidden class=anchor aria-hidden=true href=#app-administration>#</a></h2><ul><li>Django가 기본으로 제공해주는 admin을 사용합니다.</li></ul><h2 id=running-scheduled-jobs>Running scheduled jobs<a hidden class=anchor aria-hidden=true href=#running-scheduled-jobs>#</a></h2><ul><li><p>고객용 데일리 리포트, 15분 마다 사용 통계 계산, 스태프용 이메일 보내기 등 다양한 예약 작업이 있다.</p></li><li><p>Celery workers와 Celery beat를 cluster에서 실행한다. Task queue로는 Redis를 사용한다.</p></li><li><p>만약 예약 된 작업이 정상적으로 작동하지 않으면 <a href=https://healthchecks.io/ target=_blank rel=noopener>Healthchecks</a>를 통해 slack/sms/email로 알림을 받는다.</p></li><li><p>아래는 예약 된 작업의 상태를 체크하는 모니터링 코드다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>some_hourly_job</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Task logic</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Ping monitoring service once task completes</span>
</span></span><span style=display:flex><span>    TaskMonitor(
</span></span><span style=display:flex><span>    name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;send_quota_depleted_email&#34;</span>,
</span></span><span style=display:flex><span>    expected_schedule<span style=color:#f92672>=</span>timedelta(hours<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    grace_period<span style=color:#f92672>=</span>timedelta(hours<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>    )<span style=color:#f92672>.</span>ping()
</span></span></code></pre></div></li></ul><h2 id=app-configuration>App configuration<a hidden class=anchor aria-hidden=true href=#app-configuration>#</a></h2><ul><li>쿠버네티스의 configmap을 사용하여 환경 변수를 오버라이딩하고 django의 <code>settings.py</code>에 환경 변수를 정의 한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>panelbear</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>name</span>: <span style=color:#ae81ff>panelbear-webserver-config</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>INVITE_ONLY</span>: <span style=color:#e6db74>&#34;True&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>DEFAULT_FROM_EMAIL</span>: <span style=color:#e6db74>&#34;The Panelbear Team &lt;support@panelbear.com&gt;&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>SESSION_COOKIE_SECURE</span>: <span style=color:#e6db74>&#34;True&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>SECURE_HSTS_PRELOAD</span>: <span style=color:#e6db74>&#34;True&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>SECURE_SSL_REDIRECT</span>: <span style=color:#e6db74>&#34;True&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>INVITE_ONLY <span style=color:#f92672>=</span> env<span style=color:#f92672>.</span>str(<span style=color:#e6db74>&#34;INVITE_ONLY&#34;</span>, default<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span></code></pre></div><h2 id=keeping-secrets>Keeping secrets<a hidden class=anchor aria-hidden=true href=#keeping-secrets>#</a></h2><ul><li><p>쿠버네티스의 <a href=https://github.com/bitnami-labs/sealed-secrets target=_blank rel=noopener>kubeseal</a>을 사용해서 키들을 암호화한다. kubeseal은 비대칭 암호화를 한다. 그리고 오직 클러스터만 복호화 키에 접근할 권한을 가지고 있다. 암호화하면 아래와 같이 보인다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>bitnami.com/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>SealedSecret</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>panelbear-secrets</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>panelbear</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>encryptedData</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>DATABASE_CONN_URL</span>: <span style=color:#ae81ff>AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq...</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>SESSION_COOKIE_SECRET</span>: <span style=color:#ae81ff>oi7ySY1ZA9rO43cGDEq+ygByri4OJBlK......</span>
</span></span></code></pre></div></li><li><p>클러스터 안의 Secret을 보호하기 위해 AWS KMS을 사용한다. 쿠버네티스 클러스터를 생성할 때 세팅한다.</p></li><li><p>과정을 나타내면 아래와 같다.</p><ol><li>암호화 할 환경 변수를 쿠버네티스 manifest에 작성한다.</li><li>커밋하기 전에 암호화를 하고 푸시한다.</li><li>암호화 된 변수는 배포되고, 클러스터는 자동으로 컨테이너를 실행하기 전에 암호화 된 변수를 복호화 한다.</li></ol></li></ul><h2 id=relational-data-postgres>Relational data: Postgres<a hidden class=anchor aria-hidden=true href=#relational-data-postgres>#</a></h2><ul><li><p>처음에는 바닐라 postgres 컨테이너를 쿠버네티스 클러스터에서 실행했다.</p></li><li><p>프로젝트가 성장함에 따라 AWS RDS로 이전했다.</p></li><li><p>RDS를 사용함으로써 지속적인 보안 업데이트, 암호화 된 백업 같은 장점을 누릴 수 있었다.</p></li></ul><h2 id=columnar-data-clickhouse>Columnar data: ClickHouse<a hidden class=anchor aria-hidden=true href=#columnar-data-clickhouse>#</a></h2><ul><li><p>프로젝트의 분석 데이터를 실시간으로 쿼리하고 효율적이게 저장하기 위해 <a href=https://clickhouse.tech/ target=_blank rel=noopener>ClickHouse</a>를 이용했다.</p></li><li><p>이 서비스는 엄청 빠르고, 데이터 구조를 잘 잡음으로써 압축률만 잘 잡으면 저장 비용이 낮아짐. 이건 수익률을 높임.</p></li><li><p>현재 ClickHouse 인스턴스를 쿠버네티스 클러스터에 호스트해서 사용하고 있다.</p></li><li><p>쿠버네티스 CronJob을 사용해서 주기적으로 효율적인 columnar format으로 백업한 데이터를 S3로 보냄.</p></li><li><p>재난 상황이 일어났을 때 복원 할 수 있게 스크립트를 짜놓음</p></li><li><p>유일하게 써보지 않은 툴이였는데, 문서가 잘 정리되어 있어서 금방 사용하게 됨.</p></li></ul><h2 id=dns-based-service-discovery>DNS-based service discovery<a hidden class=anchor aria-hidden=true href=#dns-based-service-discovery>#</a></h2><ul><li><p>각 컨테이너끼리 쿠버네티스 내에서 서로 통신은 DNS 레코드 기반으로 이루어진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>redis://redis.weekend-project.svc.cluster:6379
</span></span></code></pre></div></li><li><p>DNS 레코드는 쿠버네티스가 자동으로 관리한다.</p></li><li><p>쿠버네티스는 자동으로 DNS 레코드를 건강한 Pod으로 동기화 한다.</p></li><li><p>위의 내용의 원리를 알고 싶으면, <a href=https://medium.com/google-cloud/understanding-kubernetes-networking-services-f0cb48e4cc82 target=_blank rel=noopener>잘 설명하고 있는 글</a> 하나를 추천한다.</p></li></ul><h2 id=version-controlled-infrastructure>Version-controlled infrastructure<a hidden class=anchor aria-hidden=true href=#version-controlled-infrastructure>#</a></h2><ul><li><p>version-controlled를 간단한 커맨드로 하고 싶어서 Docker, Terraform 그리고 Kubernetes manifest를 하나의 레포에 두었다.</p></li><li><p>이 레포는 여러 프로젝트에 대한 인프라를 가지고 있다. 즉, 여러 프로젝트들은 서로 다른 레포에 저장되어 있지만, 각 프로젝트의 인프라에 대한 관리는 이 단일 레포에서 하는 것이다.</p></li><li><p><a href=https://12factor.net/ target=_blank rel=noopener>The Twelve-Factor App</a>에 대해 알고 있다면 이 구조가 꽤 괜찮아 보일 것이다.</p></li><li><p>이렇게 해서 단순한 커맨드로 인프라로 관리할 수 있게 되었다. 아래는 인프라 단일 레포의 구조를 예시로 나타냈다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># Cloud resources
</span></span><span style=display:flex><span>terraform/
</span></span><span style=display:flex><span>    aws/
</span></span><span style=display:flex><span>        rds.tf
</span></span><span style=display:flex><span>        ecr.tf
</span></span><span style=display:flex><span>        eks.tf
</span></span><span style=display:flex><span>        lambda.tf
</span></span><span style=display:flex><span>        s3.tf
</span></span><span style=display:flex><span>        roles.tf
</span></span><span style=display:flex><span>        vpc.tf
</span></span><span style=display:flex><span>    cloudflare/
</span></span><span style=display:flex><span>        projects.tf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Kubernetes manifests
</span></span><span style=display:flex><span>manifests/
</span></span><span style=display:flex><span>    cluster/
</span></span><span style=display:flex><span>        ingress-nginx/
</span></span><span style=display:flex><span>        external-dns/
</span></span><span style=display:flex><span>        certmanager/
</span></span><span style=display:flex><span>        monitoring/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    apps/
</span></span><span style=display:flex><span>        panelbear/
</span></span><span style=display:flex><span>            webserver.yaml
</span></span><span style=display:flex><span>            celery-scheduler.yaml
</span></span><span style=display:flex><span>            celery-workers.yaml
</span></span><span style=display:flex><span>            secrets.encrypted.yaml
</span></span><span style=display:flex><span>            ingress.yaml
</span></span><span style=display:flex><span>            redis.yaml
</span></span><span style=display:flex><span>            clickhouse.yaml
</span></span><span style=display:flex><span>        another-saas/
</span></span><span style=display:flex><span>        my-weekend-project/
</span></span><span style=display:flex><span>        some-ghost-blog/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Python scripts for disaster recovery, and CI
</span></span><span style=display:flex><span>tasks/
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># In case of a fire, some help for future me
</span></span><span style=display:flex><span>README.md
</span></span><span style=display:flex><span>DISASTER.md
</span></span><span style=display:flex><span>TROUBLESHOOTING.md
</span></span></code></pre></div></li></ul><h2 id=terraform-for-cloud-resources>Terraform for cloud resources<a hidden class=anchor aria-hidden=true href=#terraform-for-cloud-resources>#</a></h2><ul><li><p><a href=https://www.terraform.io/ target=_blank rel=noopener>Terraform</a>을 사용해서 대부분의 클라우드 리소스를 관리한다.</p></li><li><p>문서화와 리소스를 추적하고 인프라를 설정하는 것에 도움을 주었다.</p></li></ul><h2 id=kubernetes-manifests-for-app-deployments>Kubernetes manifests for app deployments<a hidden class=anchor aria-hidden=true href=#kubernetes-manifests-for-app-deployments>#</a></h2><ul><li><p>쿠버네티스 manifest들은 모든 YAML 파일로 기술되어 있고 인프라 단일 레포에 위치해 있다.</p></li><li><p>두 개의 레포로 분리 했다: <code>cluster</code> & <code>app</code></p></li><li><p><code>cluster</code> 디렉토리 안에는 nginx-ingress, encryped secrets, premotheus scaper 같은 클러스터 전체 서비스의 설정에 대한 내용이 있다.</p></li><li><p><code>app</code> 디렉토리 안에는 프로젝트와 관련된 내용이 있다.</p></li></ul><h2 id=subscriptions-and-payments>Subscriptions and Payments<a hidden class=anchor aria-hidden=true href=#subscriptions-and-payments>#</a></h2><ul><li><p><a href=https://stripe.com/payments/checkout target=_blank rel=noopener>Stripe Checkout</a>으로 결제 기능을 관리한다.</p></li><li><p>결제 정보에 접근할 필요가 없으므로 프로덕트 개발에 더 집중할 수 있게 됐다.</p></li><li><p>새로운 고객 세션을 만든 뒤 Stripe가 호스트한 페이지로 리다이렉트 시킨 후 webhook을 통해 결제의 결과에 따라 나의 데이터베이스를 업데이트 하기만 하면 된다.</p></li><li><p>물론 webhook과 관련되서 중요한 부분이 있지만, Strip 문서가 잘 다뤄주고 있다.</p></li></ul><h2 id=logging>Logging<a hidden class=anchor aria-hidden=true href=#logging>#</a></h2><ul><li><p>logging을 하기 위해 특별한 agent 같은 건 사용하지 않음.</p></li><li><p>stdout을 통해 찍힌 로그를 쿠버네티스가 자동으로 수집하게 하고, 로그를 rotate 함.</p></li><li><p>ElasticSearch/Kibana 같은 자동으로 로그를 모아주는 툴을 쓸 수도 있지만, 지금은 간단하게 유지하고 싶어함.</p></li><li><p>로그를 추적하기 위해 쿠버네티스 CLI 툴인 <a href=https://github.com/wercker/stern target=_blank rel=noopener>stern</a>을 사용함.</p></li></ul><h2 id=monitoring-and-alerting>Monitoring and alerting<a hidden class=anchor aria-hidden=true href=#monitoring-and-alerting>#</a></h2><ul><li><p>처음에는 Prometheus/Grafana를 자체 호스팅해서 클러스터와 애플리케이션 수치를 모니터링 했다.</p></li><li><p>하지만 클러스터가 문제가 생기면 모니터링 툴의 alerting system도 다운되서 좋지 않다고 느꼈다.</p></li><li><p>그래서 <a href=https://newrelic.com/ target=_blank rel=noopener>New Relic</a>로 툴을 변경했다.</p></li><li><p>클러스터 내의 모든 서비스는 Prometheus integration을 가지고 있어서 자동으로 기록을 New Relic으로 보낼 수 있었다. 그래서 New Relic으로 마이그레이션 할 때 단순히 Prometheus Docker image만 사용하면 됐었다.</p></li><li><p>장고 앱의 수치를 기록하는 방법으로는 <a href=https://github.com/korfuri/django-prometheus target=_blank rel=noopener>django-prometheus</a> 라이브러리를 사용했다.</p></li></ul><h2 id=error-tracking>Error tracking<a hidden class=anchor aria-hidden=true href=#error-tracking>#</a></h2><ul><li><p>Error tracking 툴로는 <a href=https://sentry.io/welcome/ target=_blank rel=noopener>Sentry</a>를 사용했다.</p></li><li><p>장고 앱에서 샌트리를 사용하는 방법은 간단하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>SENTRY_DSN <span style=color:#f92672>=</span> env<span style=color:#f92672>.</span>str(<span style=color:#e6db74>&#34;SENTRY_DSN&#34;</span>, default<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Init Sentry if configured</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> SENTRY_DSN:
</span></span><span style=display:flex><span>    sentry_sdk<span style=color:#f92672>.</span>init(
</span></span><span style=display:flex><span>        dsn<span style=color:#f92672>=</span>SENTRY_DSN,
</span></span><span style=display:flex><span>        integrations<span style=color:#f92672>=</span>[DjangoIntegration(), RedisIntegration(), CeleryIntegration()],
</span></span><span style=display:flex><span>        <span style=color:#75715e># Do not send user PII data to Sentry</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># See also inbound rules for special patterns</span>
</span></span><span style=display:flex><span>        send_default_pii<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>        <span style=color:#75715e># Only sample a small amount of performance traces</span>
</span></span><span style=display:flex><span>        traces_sample_rate<span style=color:#f92672>=</span>env<span style=color:#f92672>.</span>float(<span style=color:#e6db74>&#34;SENTRY_TRACES_SAMPLE_RATE&#34;</span>, default<span style=color:#f92672>=</span><span style=color:#ae81ff>0.008</span>),
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div></li><li><p>또한 Slack <code>#alerts</code> 채널을 사용해서 모든 알림(downtime, cron job failures, security alerts, performance regressions, application exceptions, and whatnot.)을 이 채널로 오도록 했다.</p></li></ul><h2 id=profiling-and-other-goodies>Profiling and other goodies<a hidden class=anchor aria-hidden=true href=#profiling-and-other-goodies>#</a></h2><ul><li><a href=https://docs.python.org/3/library/profile.html target=_blank rel=noopener>cProfile</a>, <a href=https://jiffyclub.github.io/snakeviz/ target=_blank rel=noopener>snakeviz</a>, <a href=https://django-debug-toolbar.readthedocs.io/en/latest/ target=_blank rel=noopener>Django debug toolbar</a>를 통해 profiling을 했다.</li></ul><h2 id=마치면서-개인적인-생각>마치면서 (개인적인 생각)<a hidden class=anchor aria-hidden=true href=#마치면서-개인적인-생각>#</a></h2><p>저자도 앞에서 언급한 것과 같이 위에서 소개 된 도구와 방법은 정답이 아니다. 각자의 상황 또는 프로젝트의 특성에 따라 정답은 바뀔 수 있다.</p><p>그러나 프로젝트가 진행 될 때 공통적으로 필요한 기능들은 위에서 대부분 언급했고 그에 대한 하나의 선택지를 알려줬다고 생각한다.</p><p>이 글을 쓰는 나를 포함해서 글을 읽는 여러분들이, 원문의 저자가 공유해준 경험과 선택지를 참고 삼아 자신만의 정답을 찾았으면 좋겠다.</p><hr><p><strong>Reference</strong></p><ul><li><a href=https://anthonynsimon.com/blog/one-man-saas-architecture/ target=_blank rel=noopener>https://anthonynsimon.com/blog/one-man-saas-architecture/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://callmemaru.com/tags/%EA%B8%80/>글</a></li><li><a href=https://callmemaru.com/tags/%EC%9A%94%EC%95%BD/>요약</a></li><li><a href=https://callmemaru.com/tags/%EB%B2%88%EC%97%AD/>번역</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on x" href="https://x.com/intent/tweet/?text=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d&amp;url=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f&amp;hashtags=%ea%b8%80%2c%ec%9a%94%ec%95%bd%2c%eb%b2%88%ec%97%ad"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f&amp;title=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d&amp;summary=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d&amp;source=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f&title=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d%20-%20https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on telegram" href="https://telegram.me/share/url?text=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d&amp;url=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [정리] 1인 기술 스타트업의 아키텍처 스택 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%a0%95%eb%a6%ac%5d%201%ec%9d%b8%20%ea%b8%b0%ec%88%a0%20%ec%8a%a4%ed%83%80%ed%8a%b8%ec%97%85%ec%9d%98%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20%ec%8a%a4%ed%83%9d&u=https%3a%2f%2fcallmemaru.com%2fposts%2fsummary-the-architecture-behind-a-one-person-tech-startup%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//callmemaru.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://callmemaru.com/>Call Me Maru</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>